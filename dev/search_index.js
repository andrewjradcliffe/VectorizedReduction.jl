var documenterSearchIndex = {"docs":
[{"location":"#VectorizedReduction.jl-Documentation","page":"Home","title":"VectorizedReduction.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [VectorizedReduction]\nOrder   = [:function]","category":"page"},{"location":"#VectorizedReduction.vall-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vall","text":"vall([p=identity,] A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vall-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, T, N, M}","page":"Home","title":"VectorizedReduction.vall","text":"vall([p=identity,] A::AbstractArray, dims=:)\n\nDetermine whether predicate p returns true for all elements over the given dims. If p is omitted, test whether all values along the given dims are true (in which case A should be AbstractArray{Bool}).\n\nUsage Recommendation\n\nIf A is reasonably small, vall may be faster than all; however, as the size of A grows, the probability of all element returning false inevitably increases (it is repeated Bernoulli sampling, thus, even with a very small success probability,  a large number of tries makes may yield a scenario where the break of all wins out). Consequently, the probability of individual elements being true should determine choice – if one suspects a reasonable success probability, then all may be preferable, depending on the size A. More testing is needed to determine potential breakpoints.\n\nAdditional Notes\n\nThis function suffers from the same issue as vfindmax and friends – reductions which include the first dimension with max masks are not yet supported by LoopVectorization. Notably, this function still works as intended for any reduction which does not involve the first dimension.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vany-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vany","text":"vany([p=identity,] A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vany-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, T, N, M}","page":"Home","title":"VectorizedReduction.vany","text":"vany([p=identity,] A::AbstractArray, dims=:)\n\nDetermine whether predicate p returns true for any elements over the given dims. If p is omitted, test whether any values along the given dims are true (in which case A should be AbstractArray{Bool}).\n\nUsage Recommendation\n\nIf A is reasonably small, vany may be faster than any; however, as the size of A grows, the probability of any element returning true inevitably increases (it is repeated Bernoulli sampling, thus, even with a very small success probability,  a large number of tries makes may yield a scenario where the break of any wins out). Consequently, the probability of individual elements being true should determine choice – if one suspects a reasonable success probability, then any may be preferable, depending on the size A. More testing is needed to determine potential breakpoints.\n\nAdditional Notes\n\nThis function suffers from the same issue as vfindmax and friends – reductions which include the first dimension with zero masks are not yet supported by LoopVectorization. Notably, this function still works as intended for any reduction which does not involve the first dimension.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmax-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vargmax","text":"vargmax(A::AbstractArray, dims=:)\n\nReturn the index of the maximal value of A over the dimensions dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmax-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vargmax","text":"vargmax(f, A; dims)\nvargmax(A; dims)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmax-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vargmax","text":"vargmax(f, A::AbstractArray, dims=:)\n\nReturn the index of the argument which maximizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Expands upon the functionality provided in Julia Base.\n\nAdditional Notes\n\nDue to the current limitations of LoopVectorization, searches over the first dimension of an array are not well-supported. A workaround is possible by reshaping A but the resultant performance is often only on par with argmax. As a temporary convenience, vargmax1 is provided for explicit uses of the re-shaping strategy, though the user is cautioned as to the performance problems.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmax-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vargmax","text":"vargmax(f, As::Vararg{AbstractArray, N}; dims=:) where {N}\n\nReturn the index of the arguments which maximize f : ℝᴺ → ℝ over the dimensions dims. This expands upon the functionality which exists in Julia Base.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmin-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vargmin","text":"vargmin(A::AbstractArray, dims=:)\n\nReturn the index of the minimal value of A over the dimensions dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmin-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vargmin","text":"vargmin(f, A; dims)\nvargmin(A; dims)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmin-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vargmin","text":"vargmin(f, A::AbstractArray, dims=:)\n\nReturn the index of the argument which minimizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Expands upon the functionality provided in Julia Base.\n\nAdditional Notes\n\nDue to the current limitations of LoopVectorization, searches over the first dimension of an array are not well-supported. A workaround is possible by reshaping A but the resultant performance is often only on par with argmin. As a temporary convenience, vargmin1 is provided for explicit uses of the re-shaping strategy, though the user is cautioned as to the performance problems.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vargmin-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vargmin","text":"vargmin(f, As::Vararg{AbstractArray, N}; dims=:) where {N}\n\nReturn the index of the arguments which minimize f : ℝᴺ → ℝ over the dimensions dims. This expands upon the functionality which exists in Julia Base.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vchebyshev-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vchebyshev","text":"vchebyshev(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the Chebyshev distance between the vectors corresponding to the slices along the dimensions dims.\n\nSee also: vmanhattan, veuclidean, vminkowski\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vcount-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vcount","text":"vcount([f=identity,] A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vcount-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, T, N, M}","page":"Home","title":"VectorizedReduction.vcount","text":"vcount([f=identity,] A::AbstractArray, dims=:)\n\nCount the number of elements in A for which f return true over the given dims. If f is omitted, count the number of true elements in A (which should be AbstractArray{Bool}).\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vcounteq-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vcounteq","text":"vcounteq(x::AbstractArray, y::AbstractArray; dims=:)\n\nCount the number of elements for which xᵢ == yᵢ returns true on the vectors corresponding to the slices along the dimension dims.\n\nSee also: vcountne\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vcountne-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vcountne","text":"vcountne(x::AbstractArray, y::AbstractArray; dims=:)\n\nCount the number of elements for which xᵢ != yᵢ returns true on the vectors corresponding to the slices along the dimension dims.\n\nSee also: vcounteq\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.veuclidean-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.veuclidean","text":"veuclidean(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the Euclidean distance between the vectors corresponding to the slices along the dimensions dims.\n\nSee also: vmanhattan, vchebyshev, vminkowski\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmax-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vfindmax","text":"vfindmax(A::AbstractArray, dims=:) -> (x, index)\n\nReturn the maximal element and its index over the dimensions dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmax-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vfindmax","text":"vfindmax(f, A; dims) -> (f(x), index)\nvfindmax(A; dims) -> (x, index)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmax-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vfindmax","text":"vfindmax(f, A::AbstractArray, dims=:) -> (f(x), index)\n\nReturn the value and the index of the argument which maximizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Expands upon the functionality provided in Julia (v1.8) Base.\n\nAdditional Notes\n\nDue to the current limitations of LoopVectorization, searches over the first dimension of an array are not well-supported. A workaround is possible by reshaping A but the resultant performance is often only on par with findmax. As a temporary convenience, vfindmax1 is provided for explicit uses of the re-shaping strategy, though the user is cautioned as to the performance problems.\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmax-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vfindmax","text":"vfindmax(f, As::Vararg{AbstractArray, N}; dims=:) where {N} -> (f(x,y,z,...), index)\n\nReturn the value and index of the arguments which maximize f : ℝᴺ → ℝ over the dimensions dims. This expands upon the functionality which exists in Julia Base.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmin-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vfindmin","text":"vfindmin(A::AbstractArray, dims=:) -> (x, index)\n\nReturn the minimal element and its index over the dimensions dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmin-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vfindmin","text":"vfindmin(f, A; dims) -> (f(x), index)\nvfindmin(A; dims) -> (x, index)\n\nIdentical to non-keywords args versions; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmin-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vfindmin","text":"vfindmin(f, A::AbstractArray, dims=:) -> (f(x), index)\n\nReturn the value and the index of the argument which minimizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Expands upon the functionality provided in Julia (v1.8) Base.\n\nAdditional Notes\n\nDue to the current limitations of LoopVectorization, searches over the first dimension of an array are not well-supported. A workaround is possible by reshaping A but the resultant performance is often only on par with findmin. As a temporary convenience, vfindmin1 is provided for explicit uses of the re-shaping strategy, though the user is cautioned as to the performance problems.\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vfindmin-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vfindmin","text":"vfindmin(f, As::Vararg{AbstractArray, N}; dims=:) where {N} -> (f(x,y,z,...), index)\n\nReturn the value and index of the arguments which minimize f : ℝᴺ → ℝ over the dimensions dims. This expands upon the functionality which exists in Julia Base.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vlogsoftmax-Tuple{AbstractArray}","page":"Home","title":"VectorizedReduction.vlogsoftmax","text":"vlogsoftmax(A::AbstractArray)\n\nCompute the log of the softmax function, treating the entire array as a single vector. Care is taken to ensure that the computation will not overflow/underflow, but the caller should be aware that +Inf and NaN are not handled.\n\nSee also: vsoftmax\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vlogsoftmax-Tuple{Any}","page":"Home","title":"VectorizedReduction.vlogsoftmax","text":"vlogsoftmax(A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vlogsoftmax-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{M, Int64}}} where {T, N, M}","page":"Home","title":"VectorizedReduction.vlogsoftmax","text":"vlogsoftmax(A::AbstractArray, dims)\n\nCompute the log of the softmax function, treating each slice of A specified by dims as if it were a single vector; dims may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Avoids overflow/underflow, but +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vlogsumexp-Tuple{AbstractArray}","page":"Home","title":"VectorizedReduction.vlogsumexp","text":"vlogsumexp(A::AbstractArray)\n\nCompute the log of the sum of exponentials of each element of A. Care is taken to ensure that the computation will not overflow/underflow, but the caller should be aware that +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vlogsumexp-Tuple{Any}","page":"Home","title":"VectorizedReduction.vlogsumexp","text":"vlogsumexp(A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vlogsumexp-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{M, Int64}}} where {T, N, M}","page":"Home","title":"VectorizedReduction.vlogsumexp","text":"vlogsumexp(A::AbstractArray, dims)\n\nCompute the log of the sum of exponentials of each element of A along the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Avoids overflow/underflow, but +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vmanhattan-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vmanhattan","text":"vmanhattan(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the Manhattan distance between the vectors corresponding to the slices along the dimensions dims.\n\nSee also: veuclidean, vchebyshev, vminkowski\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vmapreducethen-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{I}, Tuple{G}, Tuple{OP}, Tuple{F}, Tuple{F, OP, G, I, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, OP, G, I, T, N, M}","page":"Home","title":"VectorizedReduction.vmapreducethen","text":"vmapreducethen(f, op, g, A::AbstractArray; dims=:, init)\n\nApply function f to each element of A, reduce the result over the dimensions dims using the binary function op, then apply g to the result. Equivalent to g.(mapreduce(f, op, A, dims=dims, init=init)) but avoids the intermediate implied by said expression while also fusing the post-transform g such that the output array is populated in a single pass.\n\nThe reduction necessitates an initial value init which may be <:Number or a function which accepts a single type argument (e.g. zero); init is optional for binary operators +, *, min, and max.\n\nExamples\n\njulia> vmapreducethen(abs2, +, √, [1 2; 3 4], dims=1)    # L₂-norm; see `vnorm`\n1×2 Matrix{Float64}:\n 3.16228  4.47214\n\njulia> vmapreducethen(abs2, +, √, [1 2; 3 4], dims=2, init=1000.0)\n2×1 Matrix{Float64}:\n 31.701734968294716\n 32.01562118716424\n\njulia> vmapreducethen(exp, +, log, [5 6; 7 8], dims=1)    # LSE, but recommend `vlogsumexp`\n1×2 Matrix{Float64}:\n 7.12693  8.12693\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vmapreducethen-Union{Tuple{P}, Tuple{I}, Tuple{G}, Tuple{OP}, Tuple{F}, Tuple{F, OP, G, I, Vararg{AbstractArray, P}}} where {F, OP, G, I, P}","page":"Home","title":"VectorizedReduction.vmapreducethen","text":"vmapreducethen(f, op, g, As::Vararg{AbstractArray, N}; dims=:, init) where {N}\n\nVersion of mapreducethen wherein f : ℝᴺ → ℝ, then g : ℝ → ℝ, with reduction over the dimensions dims.\n\nExamples\n\njulia> x, y, z = [1 2; 3 4], [5 6; 7 8], [9 10; 11 12];\n\njulia> vmapreducethen((a, b) -> abs2(a - b), +, √, x, y, dims=2)    # Euclidean distance\n2×1 Matrix{Float64}:\n 5.656854249492381\n 5.656854249492381\n\njulia> vmapreducethen(*, *, exp, x, y, z, dims=2, init=-1.0)\n2×1 Matrix{Float64}:\n 0.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vmaxad-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vmaxad","text":"vmaxad(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the maximum absolute deviation between the vectors corresponding to the slices along the dimension dims.\n\nSee also: vmeanad\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vmeanad-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vmeanad","text":"vmeanad(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the mean absolute deviation between the vectors corresponding to the slices along the dimension dims.\n\nSee also: vmaxad\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vminkowski-Tuple{Any, Any, Real}","page":"Home","title":"VectorizedReduction.vminkowski","text":"vminkowski(x::AbstractArray, y::AbstractArray, p::Real; dims=:)\n\nCompute the Minkowski distance between the vectors corresponding to the slices along the dimensions dims.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). vminkowski(x, y, Inf) returns the largest value in abs.(x .- y), whereas vminkowski(x, y, -Inf) returns the smallest.\n\nSee also: vmanhattan, veuclidean, vchebyshev\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vmse-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vmse","text":"vmse(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the mean squared error between the vectors corresponding to the slices along the dimension dims.\n\nSee also: vrmse\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vnorm","page":"Home","title":"VectorizedReduction.vnorm","text":"vnorm(A::AbstractArray, p::Real=2; dims=:)\n\nCompute the p-norm of A along the dimensions dims as if the corresponding slices were vectors.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). vnorm(A, Inf) returns the largest value in abs.(A), whereas vnorm(A, -Inf) returns the smallest; vnorm(A, 0) matches the behavior of LinearAlgebra.norm(A, 0).\n\nSee also: vtnorm\n\n\n\n\n\n","category":"function"},{"location":"#VectorizedReduction.vrmse-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vrmse","text":"vrmse(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the square root of the mean squared error between the vectors corresponding to the slices along the dimension dims. More efficient than sqrt.(vmse(...)) as the sqrt operation is performed at the point of generation, thereby eliminating the full traversal which would otherwise occur.\n\nSee also: vmse\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vsoftmax-Tuple{AbstractArray}","page":"Home","title":"VectorizedReduction.vsoftmax","text":"vsoftmax(A::AbstractArray)\n\nCompute the softmax function, treating the entire array as a single vector. Care is taken to ensure that the computation will not overflow/underflow, but the caller should be aware that +Inf and NaN are not handled.\n\nSee also: vlogsoftmax\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vsoftmax-Tuple{Any}","page":"Home","title":"VectorizedReduction.vsoftmax","text":"vsoftmax(A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vsoftmax-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{M, Int64}}} where {T, N, M}","page":"Home","title":"VectorizedReduction.vsoftmax","text":"vsoftmax(A::AbstractArray, dims)\n\nCompute the softmax function, treating each slice of A specified by dims as if it were a single vector; dims may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Avoids overflow/underflow, but +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtall-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtall","text":"vtall([p=identity,] A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtall-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, T, N, M}","page":"Home","title":"VectorizedReduction.vtall","text":"vtall([p=identity,] A::AbstractArray, dims=:)\n\nDetermine whether predicate p returns true for all elements over the given dims. If p is omitted, test whether all values along the given dims are true (in which case A should be AbstractArray{Bool}). Threaded.\n\nAdditional Notes\n\nThis function suffers from the same issue as vfindmax and friends – reductions which include the first dimension with max masks are not yet supported by LoopVectorization. Notably, this function still works as intended for any reduction which does not involve the first dimension.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtany-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtany","text":"vtany([p=identity,] A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtany-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, T, N, M}","page":"Home","title":"VectorizedReduction.vtany","text":"vtany([p=identity,] A::AbstractArray, dims=:)\n\nDetermine whether predicate p returns true for any elements over the given dims. If p is omitted, test whether any values along the given dims are true (in which case A should be AbstractArray{Bool}). Threaded.\n\nAdditional Notes\n\nThis function suffers from the same issue as vfindmax and friends – reductions which include the first dimension with zero masks are not yet supported by LoopVectorization. Notably, this function still works as intended for any reduction which does not involve the first dimension.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmax-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtargmax","text":"vtargmax(A::AbstractArray, dims=:)\n\nReturn the index of the maximal element over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmax-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtargmax","text":"vtargmax(f, A; dims)\nvtargmax(A; dims)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmax-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vtargmax","text":"vtargmax(f, A::AbstractArray, dims=:)\n\nReturn the index of the argument which maximizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded.\n\nSee also: vargmax\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmax-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vtargmax","text":"vargmax(f, As::Vararg{AbstractArray, N}; dims=:) where {N}\n\nReturn the index of the arguments which maximize f : ℝᴺ → ℝ over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmin-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtargmin","text":"vtargmin(A::AbstractArray, dims=:)\n\nReturn the index of the minimal element over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmin-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtargmin","text":"vtargmin(f, A; dims)\nvtargmin(A; dims)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmin-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vtargmin","text":"vtargmin(f, A::AbstractArray, dims=:)\n\nReturn the index of the argument which minimizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded.\n\nSee also: vargmin\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtargmin-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vtargmin","text":"vargmin(f, As::Vararg{AbstractArray, N}; dims=:) where {N}\n\nReturn the index of the arguments which minimize f : ℝᴺ → ℝ over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtchebyshev-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtchebyshev","text":"vtchebyshev(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the Chebyshev distance between the vectors corresponding to the slices along the dimensions dims. Threaded.\n\nSee also: vtmanhattan, vteuclidean, vtminkowski\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtcount-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtcount","text":"vtcount([f=identity,] A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtcount-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, T, N, M}","page":"Home","title":"VectorizedReduction.vtcount","text":"vtcount([f=identity,] A::AbstractArray, dims=:)\n\nCount the number of elements in A for which f return true over the given dims. If f is omitted, count the number of true elements in A (which should be AbstractArray{Bool}). Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtcounteq-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtcounteq","text":"vtcounteq(x::AbstractArray, y::AbstractArray; dims=:)\n\nCount the number of elements for which xᵢ == yᵢ returns true on the vectors corresponding to the slices along the dimension dims. Threaded.\n\nSee also: vtcountne\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtcountne-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtcountne","text":"vtcountne(x::AbstractArray, y::AbstractArray; dims=:)\n\nCount the number of elements for which xᵢ != yᵢ returns true on the vectors corresponding to the slices along the dimension dims. Threaded.\n\nSee also: vtcounteq\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vteuclidean-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vteuclidean","text":"vteuclidean(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the Euclidean distance between the vectors corresponding to the slices along the dimensions dims. Threaded.\n\nSee also: vtmanhattan, vtchebyshev, vtminkowski\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtextrema-Tuple{Any, Any, Any}","page":"Home","title":"VectorizedReduction.vtextrema","text":"vtextrema([f=identity], A::AbstractArray, dims=:)\n\nCompute the minimum and maximum values by calling f on each element of of A over the given dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtextrema-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtextrema","text":"vtextrema([f=identity], A::AbstractArray; [dims=:], [init=(mn,mx)])\n\nCompute the minimum and maximum values by calling f on each element of of A over the given dims, with the mn and mn initialized by the respective arguments of the 2-tuple init, which can be any combination of values (<:Number) or functions which accept a single type argument. Threaded.\n\nWarning\n\nNaN values are not handled!\n\nExamples\n\njulia> A = reshape(Vector(1:2:16), (2,2,2))\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> vtextrema(abs2, A, dims=(1,2), init=(typemax, 100))\n1×1×2 Array{Tuple{Int64, Int64}, 3}:\n[:, :, 1] =\n (1, 100)\n\n[:, :, 2] =\n (81, 225)\n\njulia> vtextrema(abs2, A, init=(typemax, 100))\n(1, 225)\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmax-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtfindmax","text":"vtfindmax(A::AbstractArray, dims=:) -> (x, index)\n\nReturn the maximal element and its index over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmax-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtfindmax","text":"vtfindmax(f, A; dims) -> (f(x), index)\nvtfindmax(A; dims) -> (x, index)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmax-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vtfindmax","text":"vtfindmax(f, A::AbstractArray, dims=:) -> (f(x), index)\n\nReturn the value and the index of the argument which maximizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded.\n\nSee also: vfindmax\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmax-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vtfindmax","text":"vtfindmax(f, As::Vararg{AbstractArray, N}; dims=:) where {N} -> (f(x,y,z,...), index)\n\nReturn the value and index of the arguments which maximize f : ℝᴺ → ℝ over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmin-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtfindmin","text":"vtfindmin(A::AbstractArray, dims=:) -> (x, index)\n\nReturn the minimal element and its index over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmin-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtfindmin","text":"vtfindmin(f, A; dims) -> (f(x), index)\nvtfindmin(A; dims) -> (x, index)\n\nIdentical to non-keywords args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmin-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:Function","page":"Home","title":"VectorizedReduction.vtfindmin","text":"vtfindmin(f, A::AbstractArray, dims=:) -> (f(x), index)\n\nReturn the value and the index of the argument which minimizes f over the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded.\n\nSee also: vfindmin\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtfindmin-Union{Tuple{P}, Tuple{Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vtfindmin","text":"vtfindmin(f, As::Vararg{AbstractArray, N}; dims=:) where {N} -> (f(x,y,z,...), index)\n\nReturn the value and index of the arguments which minimize f : ℝᴺ → ℝ over the dimensions dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtlogsoftmax-Tuple{Any}","page":"Home","title":"VectorizedReduction.vtlogsoftmax","text":"vtlogsoftmax(A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtlogsoftmax-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{M, Int64}}} where {T, N, M}","page":"Home","title":"VectorizedReduction.vtlogsoftmax","text":"vtlogsoftmax(A::AbstractArray, dims)\n\nCompute the log of the softmax function, treating each slice of A specified by dims as if it were a single vector; dims may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded. Avoids overflow/underflow, but +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtlogsoftmax-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Colon}} where {T, N}","page":"Home","title":"VectorizedReduction.vtlogsoftmax","text":"vtlogsoftmax(A::AbstractArray)\n\nCompute the log of the softmax function, treating the entire array as a single vector. Threaded. Care is taken to ensure that the computation will not overflow/underflow, but the caller should be aware that +Inf and NaN are not handled.\n\nSee also: vtsoftmax\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtlogsumexp-Tuple{AbstractArray}","page":"Home","title":"VectorizedReduction.vtlogsumexp","text":"vtlogsumexp(A::AbstractArray)\n\nCompute the log of the sum of exponentials of each element of A. Threaded. Care is taken to ensure that the computation will not overflow/underflow, but the caller should be aware that +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtlogsumexp-Tuple{Any}","page":"Home","title":"VectorizedReduction.vtlogsumexp","text":"vtlogsumexp(A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtlogsumexp-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{M, Int64}}} where {T, N, M}","page":"Home","title":"VectorizedReduction.vtlogsumexp","text":"vtlogsumexp(A::AbstractArray, dims)\n\nCompute the log of the sum of exponentials of each element of A along the dimensions dims, which may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded. Avoids overflow/underflow, but +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmanhattan-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtmanhattan","text":"vtmanhattan(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the Manhattan distance between the vectors corresponding to the slices along the dimensions dims. Threaded.\n\nSee also: vteuclidean, vtchebyshev, vtminkowski\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreduce-Tuple{Any, Any, Any}","page":"Home","title":"VectorizedReduction.vtmapreduce","text":"vtmapreduce(f, op, A; dims=:, init)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreduce-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{I}, Tuple{OP}, Tuple{F}, Tuple{F, OP, I, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, OP, I, T, N, M}","page":"Home","title":"VectorizedReduction.vtmapreduce","text":"vtmapreduce(f, op, init, A::AbstractArray, dims=:)\n\nApply function f to each element of A, then reduce the result over the dimensions dims using the binary function op. Threaded. See vvmapreduce for description of dims. init need not be provided when op is one of +, *, min, max.\n\nSee also: vtsum, vtprod, vtminimum, vtmaximum\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreduce-Union{Tuple{P}, Tuple{Any, Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vtmapreduce","text":"vtmapreduce(f, op, init, As::Vararg{AbstractArray, N}; dims=:, init) where {N}\n\nVersion for f : ℝᴺ → ℝ, with reduction over dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreduce-Union{Tuple{P}, Tuple{M}, Tuple{I}, Tuple{OP}, Tuple{F}, Tuple{F, OP, I, NTuple{P, AbstractArray}, NTuple{M, Int64}}} where {F, OP, I, M, P}","page":"Home","title":"VectorizedReduction.vtmapreduce","text":"vtmapreduce(f, op, init, As::Tuple{Vararg{AbstractArray}}, dims=:)\n\nVersion for f : ℝᴺ → ℝ, with reduction over dims. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreducethen-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{I}, Tuple{G}, Tuple{OP}, Tuple{F}, Tuple{F, OP, G, I, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, OP, G, I, T, N, M}","page":"Home","title":"VectorizedReduction.vtmapreducethen","text":"vtmapreducethen(f, op, g, A::AbstractArray; dims=:, init)\n\nApply function f to each element of A, reduce the result over the dimensions dims using the binary function op, then apply g to the result. Equivalent to g.(mapreduce(f, op, A, dims=dims, init=init)) but avoids the intermediate implied by said expression while also fusing the post-transform g such that the output array is populated in a single pass. Threaded.\n\nThe reduction necessitates an initial value init which may be <:Number or a function which accepts a single type argument (e.g. zero); init is optional for binary operators +, *, min, and max.\n\nExamples\n\njulia> vtmapreducethen(abs2, +, √, [1 2; 3 4], dims=1)    # L₂-norm; see `vnorm`\n1×2 Matrix{Float64}:\n 3.16228  4.47214\n\njulia> vtmapreducethen(abs2, +, √, [1 2; 3 4], dims=2, init=1000.0)\n2×1 Matrix{Float64}:\n 31.701734968294716\n 32.01562118716424\n\njulia> vtmapreducethen(exp, +, log, [5 6; 7 8], dims=1)    # LSE, but recommend `vlogsumexp`\n1×2 Matrix{Float64}:\n 7.12693  8.12693\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreducethen-Union{Tuple{P}, Tuple{Any, Any, Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vtmapreducethen","text":"vtmapreducethen(f, op, g, As::Vararg{AbstractArray, N}; dims=:, init) where {N}\n\nKeyword args version for f : ℝᴺ → ℝ, then g : ℝ → ℝ.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreducethen-Union{Tuple{P}, Tuple{I}, Tuple{G}, Tuple{OP}, Tuple{F}, Tuple{F, OP, G, I, Vararg{AbstractArray, P}}} where {F, OP, G, I, P}","page":"Home","title":"VectorizedReduction.vtmapreducethen","text":"vtmapreducethen(f, op, g, init, As::Vararg{AbstractArray, N}) where {N}\n\nVersion of mapreducethen for f : ℝᴺ → ℝ, then g : ℝ → ℝ, with reduction occurring over all dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmapreducethen-Union{Tuple{P}, Tuple{M}, Tuple{I}, Tuple{G}, Tuple{OP}, Tuple{F}, Tuple{F, OP, G, I, NTuple{P, AbstractArray}, NTuple{M, Int64}}} where {F, OP, G, I, M, P}","page":"Home","title":"VectorizedReduction.vtmapreducethen","text":"vtmapreducethen(f, op, g, init, As::Tuple{Vararg{AbstractArray}}, dims=:)\n\nVersion of mapreducethen for f : ℝᴺ → ℝ, then g : ℝ → ℝ, with reduction over given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmaxad-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtmaxad","text":"vtmaxad(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the maximum absolute deviation between the vectors corresponding to the slices along the dimension dims. Threaded.\n\nSee also: vtmeanad\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmaximum-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtmaximum","text":"vtmaximum(A::AbstractArray, dims=:)\n\nCompute the maximum value of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmaximum-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtmaximum","text":"vtmaximum(f, A; dims=:, init=typemin)\n\nCompute the maximum value of calling f on each element of A over the given dims, with the max initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmaximum-Tuple{Any}","page":"Home","title":"VectorizedReduction.vtmaximum","text":"vtmaximum(A; dims=:, init=typemin)\n\nCompute the maximum value of A over the given dims, with the max initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmaximum-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vtmaximum","text":"vtmaximum(f, A::AbstractArray, dims=:)\n\nCompute the maximum value by calling f on each element of A over the given dims.\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmeanad-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtmeanad","text":"vtmeanad(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the mean absolute deviation between the vectors corresponding to the slices along the dimension dims. Threaded.\n\nSee also: vtmaxad\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtminimum-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtminimum","text":"vtminimum(A::AbstractArray, dims=:)\n\nCompute the minimum value of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtminimum-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtminimum","text":"vtminimum(f, A; dims=:, init=typemax)\n\nCompute the minimum value of calling f on each element of A over the given dims, with the min initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtminimum-Tuple{Any}","page":"Home","title":"VectorizedReduction.vtminimum","text":"vtminimum(A; dims=:, init=typemax)\n\nCompute the minimum value of A over the given dims, with the min initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtminimum-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vtminimum","text":"vtminimum(f, A::AbstractArray, dims=:)\n\nCompute the minimum value by calling f on each element of A over the given dims.\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtminkowski-Tuple{Any, Any, Real}","page":"Home","title":"VectorizedReduction.vtminkowski","text":"vtminkowski(x::AbstractArray, y::AbstractArray, p::Real; dims=:)\n\nCompute the Minkowski distance between the vectors corresponding to the slices along the dimensions dims. Threaded.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). vtminkowski(x, y, Inf) returns the largest value in abs.(x .- y), whereas vtminkowski(x, y, -Inf) returns the smallest.\n\nSee also: vtmanhattan, vteuclidean, vtchebyshev\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtmse-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtmse","text":"vtmse(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the mean squared error between the vectors corresponding to the slices along the dimension dims. Threaded.\n\nSee also: vtrmse\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtnorm","page":"Home","title":"VectorizedReduction.vtnorm","text":"vtnorm(A::AbstractArray, p::Real=2; dims=:)\n\nCompute the p-norm of A along the dimensions dims as if the corresponding slices were vectors. Threaded.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). vtnorm(A, Inf) returns the largest value in abs.(A), whereas vtnorm(A, -Inf) returns the smallest; vnorm(A, 0) matches the behavior of LinearAlgebra.norm(A, 0).\n\nSee also: vnorm\n\n\n\n\n\n","category":"function"},{"location":"#VectorizedReduction.vtprod-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtprod","text":"vtprod(A::AbstractArray, dims=:)\n\nMultiply the elements of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtprod-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtprod","text":"vtprod(f, A; dims=:, init=one)\n\nMultiply the results of calling f on each element of A over the given dims, with the product initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtprod-Tuple{Any}","page":"Home","title":"VectorizedReduction.vtprod","text":"vtprod(A; dims=:, init=one)\n\nMultiply the elements of A over the given dims, with the product initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtprod-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vtprod","text":"vtprod(f, A::AbstractArray, dims=:)\n\nMultiply the results of calling f on each element of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtreduce-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtreduce","text":"vtreduce(op, A; dims=:, init)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtreduce-Union{Tuple{I}, Tuple{OP}, Tuple{OP, I, Any, Any}} where {OP, I}","page":"Home","title":"VectorizedReduction.vtreduce","text":"vtreduce(op, init, A::AbstractArray, dims=:)\n\nReduce A over the dimensions dims using the binary function op. See vtmapreduce for description of op, init, dims.\n\nSee also: vtsum, vtprod, vtminimum, vtmaximum\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtrmse-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtrmse","text":"vtrmse(x::AbstractArray, y::AbstractArray; dims=:)\n\nCompute the square root of the mean squared error between the vectors corresponding to the slices along the dimension dims. More efficient than sqrt.(vmse(...)) as the sqrt operation is performed at the point of generation, thereby eliminating the full traversal which would otherwise occur. Threaded.\n\nSee also: vtmse\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsoftmax-Tuple{AbstractArray}","page":"Home","title":"VectorizedReduction.vtsoftmax","text":"vtsoftmax(A::AbstractArray)\n\nCompute the softmax function, treating the entire array as a single vector. Threaded. Care is taken to ensure that the computation will not overflow/underflow, but the caller should be aware that +Inf and NaN are not handled.\n\nSee also: vtlogsoftmax\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsoftmax-Tuple{Any, Int64}","page":"Home","title":"VectorizedReduction.vtsoftmax","text":"vtsoftmax(A::AbstractArray; dims=:)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs. Threaded.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsoftmax-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{M, Int64}}} where {T, N, M}","page":"Home","title":"VectorizedReduction.vtsoftmax","text":"vtsoftmax(A::AbstractArray, dims)\n\nCompute the softmax function, treating each slice of A specified by dims as if it were a single vector; dims may be ::Int, ::NTuple{M, Int} where {M} or ::Colon. Threaded. Avoids overflow/underflow, but +Inf and NaN are not handled.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsum-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vtsum","text":"vtsum(A::AbstractArray, dims=:)\n\nSum the elements of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsum-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vtsum","text":"vtsum(f, A; dims=:, init=zero)\n\nSum the results of calling f on each element of A over the given dims, with the sum initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsum-Tuple{Any}","page":"Home","title":"VectorizedReduction.vtsum","text":"vtsum(A; dims=:, init=zero)\n\nSum the elements of A over the given dims, with the sum initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vtsum-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vtsum","text":"vtsum(f, A::AbstractArray, dims=:)\n\nSum the results of calling f on each element of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvextrema-Tuple{Any, Any, Any}","page":"Home","title":"VectorizedReduction.vvextrema","text":"vvextrema([f=identity], A::AbstractArray, dims=:)\n\nCompute the minimum and maximum values by calling f on each element of of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvextrema-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vvextrema","text":"vvextrema([f=identity], A::AbstractArray; [dims=:], [init=(mn,mx)])\n\nCompute the minimum and maximum values by calling f on each element of of A over the given dims, with the mn and mx initialized by the respective arguments of the 2-tuple init, which can be any combination of values (<:Number) or functions which accept a single type argument.\n\nWarning\n\nNaN values are not handled!\n\nExamples\n\njulia> A = reshape(Vector(1:2:16), (2,2,2))\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> vvextrema(abs2, A, dims=(1,2), init=(typemax, 100))\n1×1×2 Array{Tuple{Int64, Int64}, 3}:\n[:, :, 1] =\n (1, 100)\n\n[:, :, 2] =\n (81, 225)\n\njulia> vvextrema(abs2, A, init=(typemax, 100))\n(1, 225)\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmapreduce-Tuple{Any, Any, Any}","page":"Home","title":"VectorizedReduction.vvmapreduce","text":"vvmapreduce(f, op, A; dims=:, init)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmapreduce-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{I}, Tuple{OP}, Tuple{F}, Tuple{F, OP, I, AbstractArray{T, N}, NTuple{M, Int64}}} where {F, OP, I, T, N, M}","page":"Home","title":"VectorizedReduction.vvmapreduce","text":"vvmapreduce(f, op, init, A::AbstractArray, dims=:)\n\nApply function f to each element of A, then reduce the result over the dimensions dims using the binary function op. The reduction necessitates an initial value init which may be <:Number or a function which accepts a single type argument (e.g. zero); init is optional for binary operators +, *, min, and max. dims may be ::Int, ::NTuple{M, Int} where {M} or ::Colon.\n\nSee also: vvsum, vvprod, vvminimum, vvmaximum\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmapreduce-Union{Tuple{P}, Tuple{Any, Any, Vararg{AbstractArray, P}}} where P","page":"Home","title":"VectorizedReduction.vvmapreduce","text":"vvmapreduce(f, op, As::Vararg{AbstractArray, N}; dims=:, init) where {N}\n\nKeyword args version for f : ℝᴺ → ℝ.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmapreduce-Union{Tuple{P}, Tuple{I}, Tuple{OP}, Tuple{F}, Tuple{F, OP, I, Vararg{AbstractArray, P}}} where {F, OP, I, P}","page":"Home","title":"VectorizedReduction.vvmapreduce","text":"vvmapreduce(f, op, init, As::Vararg{AbstractArray, N}) where {N}\n\nVersion of mapreduce for f : ℝᴺ → ℝ, with reduction occurring over all dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmapreduce-Union{Tuple{P}, Tuple{M}, Tuple{I}, Tuple{OP}, Tuple{F}, Tuple{F, OP, I, NTuple{P, AbstractArray}, NTuple{M, Int64}}} where {F, OP, I, M, P}","page":"Home","title":"VectorizedReduction.vvmapreduce","text":"vvmapreduce(f, op, init, As::Tuple{Vararg{AbstractArray}}, dims=:)\n\nVersion of mapreduce for f : ℝᴺ → ℝ, with reduction over given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmaximum-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vvmaximum","text":"vvmaximum(A::AbstractArray, dims=:)\n\nCompute the maximum value of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmaximum-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vvmaximum","text":"vvmaximum(f, A; dims=:, init=typemin)\n\nCompute the maximum value of calling f on each element of A over the given dims, with the max initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmaximum-Tuple{Any}","page":"Home","title":"VectorizedReduction.vvmaximum","text":"vvmaximum(A; dims=:, init=typemin)\n\nCompute the maximum value of A over the given dims, with the max initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvmaximum-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vvmaximum","text":"vvmaximum(f, A::AbstractArray, dims=:)\n\nCompute the maximum value by calling f on each element of A over the given dims.\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvminimum-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vvminimum","text":"vvminimum(A::AbstractArray, dims=:)\n\nCompute the minimum value of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvminimum-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vvminimum","text":"vvminimum(f, A; dims=:, init=typemax)\n\nCompute the minimum value of calling f on each element of A over the given dims, with the min initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvminimum-Tuple{Any}","page":"Home","title":"VectorizedReduction.vvminimum","text":"vvminimum(A; dims=:, init=typemax)\n\nCompute the minimum value of A over the given dims, with the min initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvminimum-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vvminimum","text":"vvminimum(f, A::AbstractArray, dims=:)\n\nCompute the minimum value by calling f on each element of A over the given dims.\n\nWarning\n\nNaN values are not handled!\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvprod-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vvprod","text":"vvprod(A::AbstractArray, dims=:)\n\nMultiply the elements of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvprod-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vvprod","text":"vvprod(f, A; dims=:, init=one)\n\nMultiply the results of calling f on each element of A over the given dims, with the product initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvprod-Tuple{Any}","page":"Home","title":"VectorizedReduction.vvprod","text":"vvprod(A; dims=:, init=one)\n\nMultiply the elements of A over the given dims, with the product initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvprod-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vvprod","text":"vvprod(f, A::AbstractArray, dims=:)\n\nMultiply the results of calling f on each element of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvreduce-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vvreduce","text":"vvreduce(op, A; dims=:, init)\n\nIdentical to non-keyword args version; slightly less performant due to use of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvreduce-Union{Tuple{I}, Tuple{OP}, Tuple{OP, I, Any, Any}} where {OP, I}","page":"Home","title":"VectorizedReduction.vvreduce","text":"vvreduce(op, init, A::AbstractArray, dims=:)\n\nReduce A over the dimensions dims using the binary function op. See vvmapreduce for description of op, init, dims.\n\nSee also: vvsum, vvprod, vvminimum, vvmaximum\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvsum-Tuple{AbstractArray, Any}","page":"Home","title":"VectorizedReduction.vvsum","text":"vvsum(A::AbstractArray, dims=:)\n\nSum the elements of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvsum-Tuple{Any, Any}","page":"Home","title":"VectorizedReduction.vvsum","text":"vvsum(f, A; dims=:, init=zero)\n\nSum the results of calling f on each element of A over the given dims, with the sum initialized by init, which may be a value <:Number or a function which accepts a single type argument.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvsum-Tuple{Any}","page":"Home","title":"VectorizedReduction.vvsum","text":"vvsum(A; dims=:, init=zero)\n\nSum the elements of A over the given dims, with the sum initialized by init.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedReduction.vvsum-Union{Tuple{F}, Tuple{F, Any, Any}} where F","page":"Home","title":"VectorizedReduction.vvsum","text":"vvsum(f, A::AbstractArray, dims=:)\n\nSum the results of calling f on each element of A over the given dims.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [VectorizedReduction]\nOrder   = [:function, :type]","category":"page"}]
}
